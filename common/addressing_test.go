package common

import (
	"bytes"
	"net"
	"testing"

	. "gopkg.in/check.v1"
)

var (
	EpAddr            = net.IP{0xbe, 0xef, 0xbe, 0xef, 0xbe, 0xef, 0xbe, 0xef, 0xaa, 0xaa, 0xaa, 0xaa, 0x11, 0x11, 0x11, 0x12}
	Epv4Addr          = net.IP{0xc0, 0x0, 0x2, 0x78}
	Ep6to4Addr        = net.IP{0xbe, 0xef, 0xbe, 0xef, 0xbe, 0xef, 0xbe, 0xef, 0xaa, 0xaa, 0xaa, 0xaa, 0x11, 0x11, 0x2, 0x78}
	NodeAddr          = net.IP{0xbe, 0xef, 0xbe, 0xef, 0xbe, 0xef, 0xbe, 0xef, 0xaa, 0xaa, 0xaa, 0xaa, 0x11, 0x11, 0, 0}
	NodeID     uint32 = 0xaaaa1111
	EpID       uint16 = 0x1112
)

// Hook up gocheck into the "go test" runner.
func Test(t *testing.T) {
	TestingT(t)
}

type CommonSuite struct{}

var _ = Suite(&CommonSuite{})

func (s *CommonSuite) TestBuildEndpointAddress(c *C) {
	endAddr := Build4to6EndpointAddress(NodeAddr, Epv4Addr)

	c.Assert(bytes.Compare(endAddr, Ep6to4Addr), Equals, 0,
		Commentf("Build4to6EndpointAddress failed: %s != %s",
			endAddr.String(), Ep6to4Addr.String()))
}

func (s *CommonSuite) TestNextNetwork(c *C) {
	var tests = []struct {
		n  net.IPNet
		nn net.IP
	}{
		{
			net.IPNet{
				IP:   net.IP{0xbe, 0xef, 0xbe, 0xef, 0xbe, 0xef, 0xbe, 0xef, 0xaa, 0xaa, 0xaa, 0xaa, 0x11, 0x11, 0x11, 0x12},
				Mask: net.CIDRMask(112, 128),
			},
			net.IP{0xbe, 0xef, 0xbe, 0xef, 0xbe, 0xef, 0xbe, 0xef, 0xaa, 0xaa, 0xaa, 0xaa, 0x11, 0x12, 0x0, 0x0},
		},
		{
			net.IPNet{
				IP:   net.IP{0xbe, 0xef, 0xbe, 0xef, 0xbe, 0xef, 0xbe, 0xef, 0xaa, 0xaa, 0xaa, 0xaa, 0x11, 0x11, 0x11, 0x12},
				Mask: net.CIDRMask(113, 128),
			},
			net.IP{0xbe, 0xef, 0xbe, 0xef, 0xbe, 0xef, 0xbe, 0xef, 0xaa, 0xaa, 0xaa, 0xaa, 0x11, 0x11, 0x80, 0x0},
		},
		{
			net.IPNet{
				IP:   net.IP{0xbe, 0xef, 0xbe, 0xef, 0xbe, 0xef, 0xbe, 0xef, 0xaa, 0xaa, 0xaa, 0xaa, 0x11, 0x11, 0x11, 0x12},
				Mask: net.CIDRMask(115, 128),
			},
			net.IP{0xbe, 0xef, 0xbe, 0xef, 0xbe, 0xef, 0xbe, 0xef, 0xaa, 0xaa, 0xaa, 0xaa, 0x11, 0x11, 0x20, 0x0},
		},
		{
			net.IPNet{
				IP:   net.IP{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd0},
				Mask: net.CIDRMask(127, 128),
			},
			net.IP{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xd2},
		},
		{
			net.IPNet{
				IP:   net.IP{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
				Mask: net.CIDRMask(128, 128),
			},
			net.IPv6zero,
		},
		{
			net.IPNet{
				IP:   net.IP{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xde, 0xad},
				Mask: net.CIDRMask(120, 128),
			},
			net.IP{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdf, 0x00},
		},
	}
	for _, test := range tests {
		answer := NextNetwork(test.n)
		c.Assert(answer, DeepEquals, test.nn,
			Commentf("NextNetwork failed: input: %s, answer: %s != %s", test.n.String(), answer, test.nn))
	}
}
